"""API of the package."""

import copy
import json
import logging
import pprint
import typing as t
from os import PathLike
from pathlib import Path

import yaml
from aiohttp import web

try:
    from openapi_spec_validator import openapi_v30_spec_validator as validator
except ImportError:
    from openapi_spec_validator import openapi_v3_spec_validator as validator

from swagger_ui import aiohttp_api_doc

from .openapi.schema import SchemaMaker


def publish_schema(
    app: web.Application,
    *,
    title: str,
    version: str,
    url_path: PathLike = None,
    json_path: PathLike = None,
    yaml_path: PathLike = None,
):
    """Shortcut for making and publishing schema via url or writing to file."""
    controller = SchemaController(app)
    schema = controller.make_schema(title, version)
    controller.write(schema, json_path=json_path, yaml_path=yaml_path)
    controller.publish_as_page(schema, url_path=url_path)


class SchemaController:
    def __init__(self, app: web.Application, error_logger=None):
        self.app = app
        self.errors: t.List[Exception] = []
        self.logger = error_logger or logging.getLogger(__name__)
        self.title: str = None
        self.schema_obj = None

    def make_schema(
        self,
        title: str,
        version: str,
        validate_schema=True,
        raise_errors=True,
        include_head=False,
    ):
        self.title = title
        self.schema_obj = SchemaMaker(self.app).make_schema(
            title, version, include_head
        )
        if validate_schema:
            self._validate_autogenerated_schema(raise_errors)
        return self.schema_obj.dict()

    def collect_errors(self, schema: dict) -> t.List[Exception]:
        # Validator can change schema, so we make a copy
        schema_dict = copy.deepcopy(schema)
        return list(validator.iter_errors(schema_dict))

    def publish_as_page(
        self,
        schema: dict = None,
        schema_path: PathLike = None,
        url_path: str = "/api/doc",
        title: str = None,
        **api_doc_kwargs,
    ):
        kwargs = dict(
            title=title if title is not None else self.title,
            config=schema,
            config_path=schema_path,
            url_prefix=url_path,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        kwargs.update(api_doc_kwargs)
        aiohttp_api_doc(self.app, **kwargs)

    def write(
        self,
        schema_dict,
        json_path: PathLike = None,
        json_indent=2,
        yaml_path: PathLike = None,
        yaml_indent=2,
    ):
        if json_path is not None:
            Path(json_path).parent.mkdir(exist_ok=True, parents=True)
            with open(json_path, "w") as f:
                json.dump(schema_dict, f, indent=json_indent)
        if yaml_path is not None:
            Path(yaml_path).parent.mkdir(exist_ok=True)
            with open(yaml_path, "w") as f:
                f.write(yaml.dump(schema_dict, indent=yaml_indent))

    def _validate_autogenerated_schema(self, raise_errors=True):
        schema_dict = self.schema_obj.dict()
        self.errors = list()
        for error in validator.iter_errors(schema_dict):
            self.errors.append(error)
            self.logger.error(error)
        if not self.errors:
            return
        self.logger.error(
            "Found {} errors in schema:\n{}".format(
                len(self.errors), pprint.pformat(schema_dict)
            ),
        )
        if raise_errors:
            raise self.errors[0]
